from std import io
from std.meta import reflect


interface class _JSONEncoder<T>:
    def encode(self, T)


def _get_default_encoder<T>(writer: io.Writer) -> _JSONEncoder<T>:
    match T:
        as Text:
            return _JSONTextEncoder(writer=self._writer)
        as Int:
            return _JSONIntegerEncoder(writer=self._writer)
        as Bool:
            return _JSONBoolEncoder(writer=self._writer)
        as Option<K>:
            return _JSONOptionEncoder<K>(writer=self._writer)
        as Array<K>:
            return JSONArrayEncoder<K>(writer=self._writer)
        else:
            static_assert_unreachable()


class JSONObjectEncoder<T>:
    _writer: io.Writer

    def __new__(writer: io.Writer) -> JSONObjectEncoder<T>:
        return new(JSONObjectEncoder, _writer=writer)

    def encode(self, obj: T):
        self._writer.write(b"{")
        # How is it communicated that the return value is a compile time
        # constant, and iterating over it is unrolled and the values are also
        # compile time constants?
        first = False
        for field in reflect.get_fields<T>():
            if not first:
                self._writer.write(b",")
            else:
                first = True
            _JSONTextEncoder(writer=self._writer).encode(field.name)
            self._writer.write(b":")
            _get_default_encoder<field.type>(self._writer).encode(
                reflect.read_field<field>(obj)
            )
        self._writer.write(b"}")


class JSONArrayEncoder<T>:
    _writer: io.Writer

    def __new__(writer: io.Writer) -> JSONArrayEncoder<T>:
        return new(JSONArrayEncoder, _writer=writer)

    def encode(self, d: Array<T>):
        self.writer.write(b"[")
        first = False
        for elem in d.iter():
            if not first:
                self.writer.write(b",")
            else:
                first = True
            _get_default_encoder<T>(self._writer).encode(elem)
        self.writer.write(b"]")


class _JSONTextEncoder:
    writer: io.Writer

    def encode(self, t: Text):
        self.writer.write(b'"')
        # TODO: not technically correct.
        self.writer.write(t.encode("utf-8"))
        self.writer.write(b'"')


class _JSONIntegerEncoder:
    writer: io.Writer

    def encode(self, t: Int):
        self.writer.write(t.to_text().encode("utf-8"))


class _JSONBoolEncoder:
    writer: io.Writer

    def encode(self, b: Bool):
        if b:
            self.writer.write(b"true")
        else:
            self.writer.write(b"false")


class _JSONOptionEncoder<T>:
    writer: io.Writer

    def encode(self, o: Option<T>):
        match o:
            as Some(x):
                _get_default_encoder<T>(self._writer).encode(x)
            as None:
                self.writer.write(b"null")
